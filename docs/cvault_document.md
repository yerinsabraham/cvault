# CVault Platform Infrastructure Build Guide

This document outlines the complete phased architecture and implementation plan for building CVault as a **B2B VPN infrastructure platform** that businesses can white-label, embed via SDK, or resell under their own brand.

## Business Model

CVault is a **platform product** where:
- **Your customers** = Businesses who want VPN functionality
- **Their users** = End consumers using their apps/services
- **You provide** = VPN infrastructure, APIs, SDKs, and reference implementations
- **They handle** = Their end-user billing, branding, and customer support

The objective is to build production‑grade multi-tenant infrastructure that businesses can test, integrate, and deploy quickly.

---

# OVERALL ARCHITECTURE

CVault consists of 5 layers:

1. **VPN Network Layer** — Shared WireGuard server pool
2. **Multi-Tenant Control Plane** — API + orchestration with tenant isolation
3. **Developer Portal** — Dashboard for business customers to manage their integration
4. **SDK Layer** — Multi-tenant SDKs for easy integration (iOS, Android, Web, Desktop)
5. **Reference Clients** — Demo apps businesses can test before integrating

Everything must be modular, API‑driven, and multi-tenant from day one.

---

# AUTHENTICATION MODEL (MVP Decision)

**Recommended for MVP: CVault-Provided Authentication**

Why:
- Businesses can test immediately without integration work
- Simpler to implement and demo
- Lower barrier to entry for new customers
- Can add SSO/external auth integration later

How it works:
- You provide user registration/login APIs
- Each business customer gets isolated user pools
- Their users authenticate through your system
- Future: Add OAuth/SAML for businesses who want their own auth

This gets you to market faster while staying flexible.

---

# PHASE 1 — INFRASTRUCTURE FOUNDATION

## 1.1 Choose Hosting Strategy

**Recommended: AWS EC2 for Backend + Dedicated VPS for WireGuard**

Why this split:
- AWS for scalable backend (RDS, ElastiCache, ECS)
- VPS (DigitalOcean/Vultr/Hetzner) for WireGuard (cheaper bandwidth)
- AWS to VPS communication via secure API calls

Alternative (Simpler for MVP):
- Everything on AWS EC2 (easier to start, higher bandwidth costs later)

## 1.2 AWS Backend Setup

Create:
- **EC2 instance(s)** for API backend (t3.small to start)
- **RDS PostgreSQL** instance (db.t3.micro for MVP)
- **ElastiCache Redis** (optional, add when scaling)
- **VPC** with proper security groups
- **Elastic IP** for consistent API endpoint
- **S3 bucket** for logs and configs

Security Groups:
- API: Allow 443 (HTTPS), 22 (SSH restricted)
- RDS: Allow 5432 from API security group only
- Redis: Allow 6379 from API security group only

## 1.3 WireGuard VPS Setup

Manual Steps:
* Sign up with VPS provider (DigitalOcean/Vultr recommended)
* Create Ubuntu 22.04 server
* Assign static public IP
* Configure SSH key login
* Disable password login

Server Requirements:
* 2 GB RAM minimum (handles ~100 concurrent connections)
* Open UDP port 51820
* Enable IP forwarding

Install on Server:
* WireGuard
* UFW firewall
* Fail2ban
* Minimal Docker (for monitoring agent)

Manual Configuration Required:
* Enable net.ipv4.ip_forward
* Configure firewall rules
* Allow SSH, WireGuard UDP 51820
* Lock down SSH to specific IPs

## 1.4 Backend Server Setup (AWS EC2)

Install:
* Docker
* Docker Compose
* Nginx (reverse proxy)
* Certbot (SSL)

Outcome:
- AWS backend ready for multi-tenant API
- VPS ready for shared WireGuard server pool
- Secure communication between both

---

# PHASE 2 — WIREGUARD NETWORK LAYER (SHARED POOL)

## 2.1 Install WireGuard

On VPS server:
* Install WireGuard package
* Generate server private/public key pair
* Create server configuration file

Server Config Should Include:
* PrivateKey
* Address range (e.g. 10.8.0.1/16 for ~65k IPs)
* ListenPort 51820
* PostUp and PostDown iptables rules for NAT

Sample Config:
```
[Interface]
PrivateKey = <server_private_key>
Address = 10.8.0.1/16
ListenPort = 51820
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
```

## 2.2 IP Pool Management

**Critical for Multi-Tenancy:**

IP allocation strategy:
- Total pool: 10.8.0.0/16 (65,534 usable IPs)
- Reserve 10.8.0.1 for server
- Allocate 10.8.0.2 - 10.8.255.254 to tenant users
- Track allocated IPs in database

Backend must:
- Allocate next available IP
- Mark IP as in-use
- Release IP when device disconnects
- Handle IP conflicts

## 2.3 Peer Provisioning Model

**IMPORTANT: All peer configs generated by backend API**

Flow:
1. Tenant device requests connection (via SDK)
2. Backend generates WireGuard keypair
3. Backend allocates IP from pool
4. Backend appends peer config to server via SSH
5. Backend reloads WireGuard (`wg syncconf`)
6. Backend returns config to SDK

No manual peer creation in production.

## 2.4 Test Validation

Create one manual test peer to verify:
* Connect from Mac using WireGuard CLI
* Confirm IP change (check on ifconfig.me)
* Confirm internet routing works
* Confirm DNS resolution

Outcome:
Verified working VPN tunnel with dynamic peer provisioning model planned.

---

# PHASE 3 — MULTI-TENANT CONTROL PLANE BACKEND

This is the core of your platform. Every API call must be tenant-aware.

Backend Stack:
* **Node.js + TypeScript**
* **Fastify** (faster than Express)
* **PostgreSQL** (AWS RDS)
* **Prisma** (type-safe ORM)
* **Redis** (session cache, optional for MVP)
* **Docker + Docker Compose**

Repo Structure:
```
/backend
  /src
    /routes        # API endpoints
    /services      # Business logic
    /models        # Database models
    /middleware    # Auth, rate limiting
    /utils         # Helpers
    /workers       # Background jobs
  /prisma
    schema.prisma  # Database schema
  Dockerfile
  docker-compose.yml
```

## 3.1 Core Responsibilities

Backend must:
* Register business customers (tenants)
* Issue API keys to tenants
* Register tenant users
* Authenticate tenant users (JWT)
* Register devices per tenant user
* Generate WireGuard keypairs
* Allocate IPs from shared pool
* Generate peer configs dynamically
* Track connection sessions
* Meter usage per tenant (bandwidth, connection time)
* Provide REST API for SDK consumption
* Communicate with WireGuard server securely

## 3.2 Multi-Tenant Database Schema

**Tenants Table** (Your business customers)
```sql
id                 UUID PRIMARY KEY
name               VARCHAR(255)
api_key            VARCHAR(255) UNIQUE  -- Unique key per business
api_secret_hash    VARCHAR(255)         -- Hashed secret
status             ENUM('active', 'suspended', 'trial')
bandwidth_limit_gb INT DEFAULT NULL     -- NULL = unlimited
user_limit         INT DEFAULT NULL     -- NULL = unlimited
max_devices_per_user INT DEFAULT 5
whitelabel_config  JSONB DEFAULT '{}'   -- Branding, custom domains
created_at         TIMESTAMP
```

**TenantUsers Table** (End users of your business customers)
```sql
id                 UUID PRIMARY KEY
tenant_id          UUID REFERENCES tenants(id)
external_user_id   VARCHAR(255)         -- Optional, if they use their auth
email              VARCHAR(255)         -- If using CVault auth
password_hash      VARCHAR(255)         -- If using CVault auth
created_at         TIMESTAMP
UNIQUE(tenant_id, email)               -- Email unique per tenant
UNIQUE(tenant_id, external_user_id)    -- External ID unique per tenant
```

**Devices Table**
```sql
id                 UUID PRIMARY KEY
tenant_user_id     UUID REFERENCES tenant_users(id)
device_name        VARCHAR(255)
public_key         VARCHAR(255) UNIQUE
private_key_encrypted VARCHAR(255)     -- Encrypted, for config retrieval
assigned_ip        VARCHAR(15) UNIQUE  -- 10.8.x.x
server_id          UUID REFERENCES servers(id)
status             ENUM('active', 'revoked')
last_connected_at  TIMESTAMP
created_at         TIMESTAMP
```

**Sessions Table** (Active VPN connections)
```sql
id                 UUID PRIMARY KEY
device_id          UUID REFERENCES devices(id)
server_id          UUID REFERENCES servers(id)
tenant_id          UUID REFERENCES tenants(id) -- Denormalized for queries
connected_at       TIMESTAMP
disconnected_at    TIMESTAMP
bandwidth_mb       FLOAT DEFAULT 0
status             ENUM('active', 'disconnected')
```

**Servers Table** (WireGuard server pool)
```sql
id                 UUID PRIMARY KEY
name               VARCHAR(255)
region             VARCHAR(50)          -- us-east, eu-west, etc.
public_ip          VARCHAR(15)
public_key         VARCHAR(255)
endpoint_port      INT DEFAULT 51820
capacity           INT DEFAULT 100      -- Max concurrent connections
current_load       INT DEFAULT 0
status             ENUM('active', 'maintenance', 'offline')
created_at         TIMESTAMP
```

**UsageMetrics Table** (For future billing)
```sql
id                 UUID PRIMARY KEY
tenant_id          UUID REFERENCES tenants(id)
date               DATE
bandwidth_mb       FLOAT
connection_minutes INT
active_users       INT
api_calls          INT
created_at         TIMESTAMP
UNIQUE(tenant_id, date)
```

**IPPool Table** (Track allocated IPs)
```sql
id                 UUID PRIMARY KEY
ip_address         VARCHAR(15) UNIQUE
server_id          UUID REFERENCES servers(id)
device_id          UUID REFERENCES devices(id) NULL
status             ENUM('available', 'allocated', 'reserved')
allocated_at       TIMESTAMP
```

## 3.3 API Key Authentication

Every SDK request must include:
```
X-API-Key: tenant_abc123xyz
X-API-Secret: secret_hash_here
```

Middleware validates:
1. API key exists and is active
2. Tenant is not suspended
3. Within usage limits
4. Rate limiting per tenant

## 3.4 WireGuard Integration

Backend communicates with WireGuard server via SSH:

```typescript
// services/wireguard.service.ts
async function addPeer(serverId: string, publicKey: string, ip: string) {
  const server = await getServerById(serverId);
  
  // SSH to server and add peer
  await sshExec(server.public_ip, `
    wg set wg0 peer ${publicKey} allowed-ips ${ip}/32
  `);
  
  // Persist config
  await sshExec(server.public_ip, `
    wg-quick save wg0
  `);
}

async function removePeer(serverId: string, publicKey: string) {
  const server = await getServerById(serverId);
  
  await sshExec(server.public_ip, `
    wg set wg0 peer ${publicKey} remove
  `);
  
  await sshExec(server.public_ip, `
    wg-quick save wg0
  `);
}
```

**Security:** Use SSH keys stored in environment, never in code.

## 3.5 API Endpoints

### Tenant Management (Internal/Admin only for MVP)
```
POST   /admin/tenants          # Create new business customer
GET    /admin/tenants/:id      # Get tenant details
PATCH  /admin/tenants/:id      # Update tenant settings
DELETE /admin/tenants/:id      # Suspend tenant
```

### Authentication (SDK-facing)
```
POST /api/v1/auth/register     # Register tenant user
POST /api/v1/auth/login        # Login tenant user
POST /api/v1/auth/refresh      # Refresh JWT
```

**Headers Required:**
- X-API-Key (identifies tenant)
- X-API-Secret

**Body (register):**
```json
{
  "email": "user@example.com",
  "password": "secure_password"
}
```

**Response:**
```json
{
  "user_id": "uuid",
  "access_token": "jwt_token",
  "refresh_token": "refresh_token"
}
```

### Device Management
```
POST /api/v1/devices           # Register device
GET  /api/v1/devices           # List user's devices
DELETE /api/v1/devices/:id     # Remove device
```

**Headers Required:**
- X-API-Key
- Authorization: Bearer <jwt>

**Body (register device):**
```json
{
  "device_name": "MacBook Pro"
}
```

**Response:**
```json
{
  "device_id": "uuid",
  "config": "<full WireGuard config>",
  "assigned_ip": "10.8.0.45"
}
```

### VPN Connection
```
POST /api/v1/vpn/connect       # Initiate connection
POST /api/v1/vpn/disconnect    # End connection
GET  /api/v1/vpn/status        # Get connection status
```

**Body (connect):**
```json
{
  "device_id": "uuid",
  "server_region": "us-east"  // optional
}
```

**Response:**
```json
{
  "session_id": "uuid",
  "server_ip": "1.2.3.4",
  "server_port": 51820,
  "status": "connected"
}
```

### Server List
```
GET /api/v1/servers            # List available servers
```

**Response:**
```json
{
  "servers": [
    {
      "id": "uuid",
      "region": "us-east",
      "load": 45,
      "available": true
    }
  ]
}
```

### Usage Metrics (for tenant dashboard)
```
GET /api/v1/usage              # Get tenant usage stats
```

**Response:**
```json
{
  "current_period": {
    "bandwidth_gb": 45.2,
    "active_users": 123,
    "connection_hours": 5430
  }
}
```

## 3.6 Security Requirements

* Hash passwords with bcrypt (cost 12)
* Validate JWT on every protected endpoint
* Encrypt device private keys at rest
* Use environment variables for secrets
* Enable HTTPS only (enforce with middleware)
* Rate limit per tenant (100 req/min for MVP)
* Sanitize all inputs
* Use prepared statements (Prisma handles this)
* Store API secrets hashed
* Log all authentication attempts

## 3.7 AWS Deployment Notes

**Environment Variables (.env):**
```
DATABASE_URL=postgresql://user:pass@rds-endpoint:5432/cvault
REDIS_URL=redis://elasticache-endpoint:6379
JWT_SECRET=<long_random_string>
API_ENCRYPTION_KEY=<32_byte_key>
WG_SERVER_SSH_KEY_PATH=/secrets/wg-server-key
AWS_REGION=us-east-1
```

**Deploy with Docker:**
```bash
# Build image
docker build -t cvault-backend .

# Push to ECR
aws ecr get-login-password | docker login --username AWS --password-stdin <ecr-url>
docker tag cvault-backend:latest <ecr-url>/cvault-backend:latest
docker push <ecr-url>/cvault-backend:latest

# Run on EC2 or ECS
docker-compose up -d
```

Outcome:
Multi-tenant backend capable of provisioning VPN connections for multiple businesses simultaneously.

---

# PHASE 4 — MULTI-TENANT SDK LAYER

SDKs are how businesses integrate your VPN into their apps. Each SDK must support tenant-specific API keys.

Repo Structure:
```
/sdk-js          # JavaScript/TypeScript (Web, Node.js)
/sdk-flutter     # Flutter/Dart (Mobile, Desktop)
/sdk-swift       # iOS native (future)
/sdk-kotlin      # Android native (future)
```

## 4.1 JavaScript/TypeScript SDK

**Target Platforms:** Web browsers, Node.js, Electron apps

**Installation:**
```bash
npm install @cvault/sdk-js
```

**API Interface:**
```typescript
import CVault from '@cvault/sdk-js';

// Initialize with tenant API key
const cvault = new CVault({
  apiKey: 'tenant_abc123',
  apiSecret: 'secret_xyz',
  baseUrl: 'https://api.cvault.io'
});

// Tenant user registration
const user = await cvault.auth.register({
  email: 'user@example.com',
  password: 'secure_password'
});

// Login
const session = await cvault.auth.login({
  email: 'user@example.com',
  password: 'secure_password'
});

// Register device
const device = await cvault.devices.register({
  deviceName: 'MacBook Pro'
});

// Get WireGuard config
const config = device.config;  // Full WireGuard config string

// List available servers
const servers = await cvault.servers.list();

// Connect (records session on backend)
const connection = await cvault.vpn.connect({
  deviceId: device.id,
  serverRegion: 'us-east'
});

// Check status
const status = await cvault.vpn.status();

// Disconnect
await cvault.vpn.disconnect();

// Get usage stats (for tenant dashboard)
const usage = await cvault.usage.get();
```

**SDK Responsibilities:**
- Store JWT securely (localStorage for web, secure storage for mobile)
- Auto-refresh JWT when expired
- Handle API errors gracefully
- Retry failed requests (with exponential backoff)
- Emit events (onConnected, onDisconnected, onError)

**SDK Does NOT:**
- Implement VPN tunnel itself
- Store WireGuard keys insecurely
- Contain business logic

## 4.2 Flutter SDK

**Target Platforms:** iOS, Android, macOS, Windows, Linux

**Installation:**
```yaml
dependencies:
  cvault_sdk: ^1.0.0
```

**API Interface:**
```dart
import 'package:cvault_sdk/cvault_sdk.dart';

// Initialize
final cvault = CVault(
  apiKey: 'tenant_abc123',
  apiSecret: 'secret_xyz',
  baseUrl: 'https://api.cvault.io',
);

// Register user
final user = await cvault.auth.register(
  email: 'user@example.com',
  password: 'secure_password',
);

// Login
final session = await cvault.auth.login(
  email: 'user@example.com',
  password: 'secure_password',
);

// Register device
final device = await cvault.devices.register(
  deviceName: 'iPhone 15',
);

// Get config
final config = device.config;  // WireGuard config string

// Connect (call system VPN via platform channel)
await cvault.vpn.connect(
  deviceId: device.id,
  serverRegion: 'us-east',
);

// Status stream
cvault.vpn.statusStream.listen((status) {
  print('VPN Status: $status');
});

// Disconnect
await cvault.vpn.disconnect();
```

**Platform Integration:**

Flutter SDK must use **platform channels** to interact with system VPN:

- **iOS:** NetworkExtension framework
- **Android:** VpnService API
- **macOS/Windows/Linux:** WireGuard CLI

```dart
// platform_channel.dart
class WireGuardChannel {
  static const platform = MethodChannel('io.cvault/wireguard');
  
  Future<void> connect(String config) async {
    await platform.invokeMethod('connect', {'config': config});
  }
  
  Future<void> disconnect() async {
    await platform.invokeMethod('disconnect');
  }
  
  Stream<String> get statusStream {
    return EventChannel('io.cvault/vpn_status')
        .receiveBroadcastStream()
        .map((event) => event as String);
  }
}
```

## 4.3 SDK Documentation

Each SDK must include:

**README.md:**
- Installation instructions
- Quick start guide
- Authentication flow
- Example usage

**API Reference:**
- All methods documented
- Request/response examples
- Error codes

**Example Apps:**
- Simple demo app
- Full featured reference app

## 4.4 SDK Security

* Never log API secrets
* Store JWT in secure storage (Keychain/Keystore)
* Clear credentials on logout
* Validate SSL certificates
* Use HTTPS only
* Encrypt WireGuard config at rest

## 4.5 Error Handling

SDK must handle common errors:

```typescript
try {
  await cvault.vpn.connect();
} catch (error) {
  if (error.code === 'TENANT_SUSPENDED') {
    // Show message to business customer
  } else if (error.code === 'BANDWIDTH_LIMIT_EXCEEDED') {
    // Notify user
  } else if (error.code === 'INVALID_API_KEY') {
    // Configuration error
  }
}
```

Standard Error Codes:
- `INVALID_API_KEY` - Wrong tenant credentials
- `TENANT_SUSPENDED` - Business account suspended
- `BANDWIDTH_LIMIT_EXCEEDED` - Tenant over quota
- `USER_LIMIT_EXCEEDED` - Too many users
- `DEVICE_LIMIT_EXCEEDED` - User has too many devices
- `SERVER_UNAVAILABLE` - No servers available
- `INVALID_CREDENTIALS` - Wrong user email/password
- `NETWORK_ERROR` - Connection failed

Outcome:
SDKs ready for businesses to integrate into their apps with minimal code.

---

# PHASE 5 — REFERENCE CLIENTS (DEMO APPS)

These are **demonstration apps** that businesses can test before integrating. They showcase the full functionality and serve as integration examples.

Project Structure:
```
/demo-desktop     # Flutter desktop (Mac, Windows, Linux)
/demo-mobile      # Flutter mobile (iOS, Android)
/demo-web         # React web app
```

## 5.1 Desktop Reference Client (Flutter)

**Purpose:** Show businesses how VPN works on desktop platforms before they integrate.

**Platform Support:**
- macOS (primary for your testing)
- Windows
- Linux

**Features:**
- Tenant API key configuration screen
- User registration/login
- Device registration
- Server selection (region picker)
- Connect/disconnect button
- Connection status indicator
- Real-time bandwidth usage
- IP address display (before/after VPN)
- Connection logs

**UI Flow:**
```
1. Configure Screen
   └─ Enter tenant API key/secret
   └─ Save config locally
   
2. Authentication Screen
   └─ Register or Login
   └─ Store JWT
   
3. Main Dashboard
   ├─ Connection status widget
   ├─ Server selection dropdown
   ├─ Connect/Disconnect button
   ├─ Current IP display
   └─ Bandwidth counter
   
4. Settings Screen
   ├─ Device management
   ├─ Auto-connect toggle
   ├─ Kill switch toggle (future)
   └─ Logout
```

**WireGuard Integration:**

**macOS:**
```dart
// Use Process to call WireGuard CLI
import 'dart:io';

Future<void> connectVPN(String config) async {
  // Write config to file
  final configFile = File('/tmp/cvault.conf');
  await configFile.writeAsString(config);
  
  // Connect using wg-quick
  final result = await Process.run(
    'wg-quick',
    ['up', '/tmp/cvault.conf'],
    runInShell: true,
  );
  
  if (result.exitCode != 0) {
    throw Exception('Failed to connect: ${result.stderr}');
  }
}

Future<void> disconnectVPN() async {
  await Process.run(
    'wg-quick',
    ['down', '/tmp/cvault.conf'],
    runInShell: true,
  );
}
```

**Windows:**
```dart
Future<void> connectVPN(String config) async {
  // Write config
  final configPath = r'C:\ProgramData\CVault\config.conf';
  await File(configPath).writeAsString(config);
  
  // Use wireguard.exe
  await Process.run(
    r'C:\Program Files\WireGuard\wireguard.exe',
    ['/installtunnelservice', configPath],
  );
}
```

**Important:** Desktop app MUST NOT generate WireGuard keys itself. It requests config from backend via SDK.

## 5.2 Mobile Reference Client (Flutter)

**Purpose:** Demo app for iOS and Android that businesses can test on their phones.

**Platform Support:**
- iOS 14+ (uses NetworkExtension)
- Android 7+ (uses VpnService API)

**Features:** (Same as desktop)
- API key configuration
- User auth
- Server selection
- Connect/disconnect
- Status indicators
- Settings

**Platform-Specific Code:**

**iOS (Swift):**
```swift
// ios/Runner/VPNManager.swift
import NetworkExtension

class VPNManager {
    func connect(config: String) {
        let manager = NEVPNManager.shared()
        let proto = NEVPNProtocolWireGuard()
        
        // Parse config and set WireGuard parameters
        proto.serverAddress = serverIP
        // ... more config
        
        manager.protocolConfiguration = proto
        manager.isEnabled = true
        
        manager.saveToPreferences { error in
            if error == nil {
                try? manager.connection.startVPNTunnel()
            }
        }
    }
}
```

**Android (Kotlin):**
```kotlin
// android/app/src/main/kotlin/VPNService.kt
import android.net.VpnService

class CVaultVPNService : VpnService() {
    fun connect(config: String) {
        val builder = Builder()
        // Parse WireGuard config
        builder.setSession("CVault")
        builder.addAddress(clientIP, 32)
        builder.addRoute("0.0.0.0", 0)
        
        val tunnel = builder.establish()
        // Start WireGuard tunnel
    }
}
```

## 5.3 Web Demo App (React)

**Purpose:** Let businesses test VPN from browser (limited functionality).

**Note:** Web browsers cannot create actual VPN tunnels, but you can demo:
- Authentication flow
- Device registration
- Server selection UI
- API integration
- Config retrieval
- Dashboard UI

**Tech Stack:**
- React + TypeScript
- CVault JS SDK
- Tailwind CSS

**Features:**
- API key config form
- User login/register
- Device management
- Server list viewer
- WireGuard config display (show, don't apply)
- Usage stats dashboard
- "Download config" button (for manual testing)

**Use Case:**
Businesses can test your API integration from browser and see how SDK works before building their own apps.

## 5.4 Build & Distribution

**Desktop Builds:**

**macOS:**
```bash
cd demo-desktop
flutter build macos --release
# Output: build/macos/Build/Products/Release/CVault Demo.app

# Sign if needed
codesign -s "Developer ID" "CVault Demo.app"
```

**Windows:**
```bash
flutter build windows --release
# Output: build/windows/runner/Release/cvault_demo.exe
```

**Mobile Builds:**

**iOS:**
```bash
flutter build ios --release
# Open in Xcode for signing and TestFlight upload
```

**Android:**
```bash
flutter build apk --release
# Output: build/app/outputs/flutter-apk/app-release.apk
```

**Web Build:**
```bash
cd demo-web
npm run build
# Deploy to S3 + CloudFront
aws s3 sync build/ s3://demo.cvault.io
```

## 5.5 Demo App Requirements

* Clear "This is a demo" messaging
* Easy config of tenant API key
* Show full capabilities
* Clean, professional UI
* Error messages that guide users
* Logs for debugging
* About page with documentation link

Outcome:
Working demo apps on all platforms that businesses can test before integrating.

---

# PHASE 6 — DEVELOPER PORTAL (TENANT DASHBOARD)

This is where your **business customers** manage their CVault integration.

Tech Stack:
- **Next.js** (React framework)
- **TypeScript**
- **Tailwind CSS**
- **Recharts** (for analytics)

Repo Structure:
```
/developer-portal
  /app
    /dashboard
    /auth
    /settings
  /components
  /lib
```

## 6.1 Core Features

**Authentication (for tenant admins):**
- Sign up form (creates new tenant)
- Login form
- Password reset

**Dashboard Home:**
- Current usage metrics
  - Active users count
  - Bandwidth used (GB)
  - Connection hours
  - API calls count
- Usage graphs (last 30 days)
- Server status indicators
- Recent activity log

**API Keys Management:**
- Display API key and secret
- Regenerate API key
- Copy to clipboard buttons
- Usage per key (future: multiple keys)

**Usage Analytics:**
- Bandwidth over time (chart)
- Users over time (chart)
- Peak usage hours
- Geographic distribution (by server region)
- Export CSV reports

**Settings:**
- Business profile (name, contact)
- Webhook URLs (for events)
- White-label config (future)
  - Custom branding
  - Custom domains
- Notification preferences
- Billing info placeholder (future)

**Documentation:**
- Embedded API docs (Swagger UI)
- Integration guides
- SDK download links
- Code examples
- Video tutorials placeholder

**Support:**
- Contact form
- Status page link
- FAQ

## 6.2 Key Pages

**Signup Page** (`/signup`)
```
Create Your CVault Account
- Business name
- Email
- Password
- [Sign Up]

→ Creates tenant in database
→ Generates API key/secret
→ Sends welcome email
```

**Dashboard** (`/dashboard`)
```
┌─────────────────────────────────────┐
│ Overview - Last 30 Days             │
├─────────────────────────────────────┤
│ Active Users: 145                   │
│ Bandwidth: 342 GB                   │
│ Connection Hours: 3,240             │
│ Uptime: 99.8%                       │
└─────────────────────────────────────┘

[Bandwidth Usage Chart]
[Active Users Chart]

Recent Activity:
- User connected (us-east) - 2 min ago
- New device registered - 15 min ago
```

**API Keys** (`/api-keys`)
```
Your API Credentials

API Key: tenant_abc123xyz
[Copy] [Regenerate]

API Secret: ••••••••••••••
[Show] [Regenerate]

⚠️ Keep your secret secure. Never expose it in client-side code.

Usage This Month:
- API Calls: 45,234
- Rate Limit: 100,000/month
```

**Documentation** (`/docs`)
```
Quick Start
- Getting Started Guide
- Authentication Flow
- SDK Integration

API Reference
- [Interactive API Docs]
- Endpoints
- Error Codes

SDKs
- [Download JS SDK]
- [Download Flutter SDK]
- Code Examples
```

## 6.3 API for Developer Portal

Backend needs endpoints for tenant management:

```
# Tenant auth
POST /api/v1/tenant/auth/signup
POST /api/v1/tenant/auth/login
POST /api/v1/tenant/auth/refresh

# Tenant dashboard
GET  /api/v1/tenant/dashboard/stats
GET  /api/v1/tenant/dashboard/usage
GET  /api/v1/tenant/dashboard/activity

# API key management
POST /api/v1/tenant/api-keys/regenerate
GET  /api/v1/tenant/api-keys

# Settings
GET  /api/v1/tenant/settings
PATCH /api/v1/tenant/settings
```

## 6.4 Deployment

**Host on AWS:**
```bash
# Build Next.js app
npm run build

# Deploy to S3 + CloudFront (static export)
# OR deploy to Vercel
# OR run on EC2/ECS (SSR)

# Domain: portal.cvault.io or dashboard.cvault.io
```

**Environment Variables:**
```
NEXT_PUBLIC_API_URL=https://api.cvault.io
JWT_SECRET=<same_as_backend>
```

Outcome:
Professional dashboard where businesses can sign up, get API keys, and monitor their usage.

---

# PHASE 7 — DOMAIN, SSL, AND NETWORKING

Set up production domains and secure all endpoints.

## 7.1 Domain Setup

**Purchase Domains:**
- `cvault.io` (main brand)
- `api.cvault.io` (backend API)
- `portal.cvault.io` (developer dashboard)
- `demo.cvault.io` (demo web app)

**DNS Configuration:**

Via AWS Route 53 or Cloudflare:

```
api.cvault.io      A     -> AWS EC2 Elastic IP
portal.cvault.io   CNAME -> CloudFront distribution
demo.cvault.io     CNAME -> CloudFront distribution
vpn1.cvault.io     A     -> WireGuard VPS IP
```

## 7.2 SSL Certificates

**Backend API (AWS EC2):**

Install Certbot:
```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d api.cvault.io
```

Auto-renewal:
```bash
sudo certbot renew --dry-run
```

**Frontend (CloudFront):**
- Use AWS Certificate Manager (ACM)
- Request certificate for `portal.cvault.io`, `demo.cvault.io`
- Attach to CloudFront distribution
- Force HTTPS redirect

## 7.3 Nginx Configuration (Backend)

```nginx
# /etc/nginx/sites-available/cvault-api

server {
    listen 80;
    server_name api.cvault.io;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.cvault.io;

    ssl_certificate /etc/letsencrypt/live/api.cvault.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.cvault.io/privkey.pem;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;

    # Proxy to backend
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/m;
    limit_req zone=api_limit burst=20 nodelay;
}
```

Enable site:
```bash
sudo ln -s /etc/nginx/sites-available/cvault-api /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

## 7.4 Firewall Configuration (AWS Security Groups)

**Backend EC2:**
- Port 22 (SSH) - Your IP only
- Port 80 (HTTP) - 0.0.0.0/0 (redirects to HTTPS)
- Port 443 (HTTPS) - 0.0.0.0/0
- Port 5432 (PostgreSQL) - Only from backend security group

**WireGuard VPS (UFW):**
```bash
sudo ufw allow 51820/udp  # WireGuard
sudo ufw allow 22/tcp     # SSH (restrict to specific IP)
sudo ufw enable
```

## 7.5 CORS Configuration

Backend must allow requests from your frontends:

```typescript
// backend/src/app.ts
import cors from '@fastify/cors';

await app.register(cors, {
  origin: [
    'https://portal.cvault.io',
    'https://demo.cvault.io',
    'http://localhost:3000',  // Development
  ],
  credentials: true,
});
```

Outcome:
All services running on secure HTTPS with proper domains.

---

# PHASE 8 — SECURITY HARDENING

Lock down all infrastructure before going live.

## 8.1 Server Security (AWS EC2 & WireGuard VPS)

**SSH Hardening:**
```bash
# Disable password auth
sudo nano /etc/ssh/sshd_config
# Set: PasswordAuthentication no
# Set: PermitRootLogin no
# Set: PubkeyAuthentication yes

sudo systemctl restart sshd
```

**Install Fail2ban:**
```bash
sudo apt install fail2ban
sudo systemctl enable fail2ban
sudo systemctl start fail2ban

# Configure
sudo nano /etc/fail2ban/jail.local
```

```ini
[sshd]
enabled = true
port = 22
maxretry = 3
bantime = 3600

[nginx-limit-req]
enabled = true
filter = nginx-limit-req
logpath = /var/log/nginx/error.log
maxretry = 5
```

**Auto-Updates:**
```bash
sudo apt install unattended-upgrades
sudo dpkg-reconfigure --priority=low unattended-upgrades
```

**Disable Unused Services:**
```bash
sudo systemctl disable apache2
sudo systemctl list-unit-files --state=enabled
```

## 8.2 Application Security

**Environment Variables:**
Never commit secrets. Use `.env` files:

```bash
# backend/.env (never commit this!)
DATABASE_URL=postgresql://...
JWT_SECRET=<64_char_random_string>
API_ENCRYPTION_KEY=<32_byte_hex>
WG_SSH_PRIVATE_KEY_PATH=/secrets/wg-key
STRIPE_SECRET_KEY=sk_live_...
```

**Secrets Management:**

For production, use AWS Secrets Manager:
```bash
# Store secret
aws secretsmanager create-secret \
  --name cvault/jwt-secret \
  --secret-string "your-secret-here"

# Retrieve in code
import { SecretsManagerClient, GetSecretValueCommand } from "@aws-sdk/client-secrets-manager";
const secret = await client.send(new GetSecretValueCommand({
  SecretId: "cvault/jwt-secret"
}));
```

**Input Validation:**
```typescript
// Use Zod for validation
import { z } from 'zod';

const RegisterSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(8).max(128),
});

app.post('/auth/register', async (req, reply) => {
  const { email, password } = RegisterSchema.parse(req.body);
  // ... rest of logic
});
```

**SQL Injection Prevention:**
Prisma uses prepared statements automatically, but always:
- Never concatenate user input into queries
- Use parameterized queries
- Validate and sanitize all inputs

**Rate Limiting:**
```typescript
import rateLimit from '@fastify/rate-limit';

await app.register(rateLimit, {
  max: 100,  // requests
  timeWindow: '1 minute',
  keyGenerator: (req) => {
    return req.headers['x-api-key'] || req.ip;
  }
});
```

**JWT Security:**
```typescript
// Use strong secrets (256-bit minimum)
// Set short expiry (15 minutes for access tokens)
// Use refresh tokens for longer sessions
const accessToken = jwt.sign(
  { userId, tenantId },
  process.env.JWT_SECRET,
  { expiresIn: '15m', algorithm: 'HS256' }
);
```

## 8.3 Database Security

**Connection Security:**
- Use SSL/TLS for PostgreSQL connections
- Restrict access to VPC only (AWS Security Groups)
- Use IAM authentication for RDS (recommended)

**Backup Strategy:**
```bash
# AWS RDS automated backups (enable in console)
# Retention: 7 days minimum
# Enable point-in-time recovery

# Manual backup script
pg_dump -h rds-endpoint -U dbuser cvault > backup.sql
# Upload to S3
aws s3 cp backup.sql s3://cvault-backups/$(date +%Y%m%d).sql
```

**Encryption:**
- Enable encryption at rest (RDS setting)
- Encrypt backups
- Encrypt sensitive fields (device private keys)

## 8.4 WireGuard Security

**Key Management:**
- Generate keys on server only
- Never log private keys
- Rotate server keys annually
- Revoke compromised keys immediately

**IP Tables Security:**
```bash
# Only allow forwarding through WireGuard
iptables -A FORWARD -i wg0 -j ACCEPT
iptables -A FORWARD -o wg0 -j ACCEPT
iptables -A FORWARD -j DROP
```

## 8.5 Monitoring & Logging

**Application Logs:**
```typescript
// Use structured logging
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  redact: ['password', 'api_secret', 'private_key'],
});

logger.info({ userId, action: 'login' }, 'User logged in');
```

**Security Event Logging:**
Log:
- Failed login attempts
- API key usage
- Admin actions
- Connection/disconnection events
- Rate limit violations
- Unusual bandwidth usage

**AWS CloudWatch:**
```bash
# Install CloudWatch agent
wget https://s3.amazonaws.com/amazoncloudwatch-agent/...
sudo dpkg -i amazon-cloudwatch-agent.deb

# Configure to send logs
sudo /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
  -a fetch-config \
  -m ec2 \
  -c file:/opt/aws/amazon-cloudwatch-agent/config.json \
  -s
```

**Alert Rules:**
Set up CloudWatch alarms for:
- CPU > 80%
- Disk > 85%
- Failed login rate spike
- API error rate > 5%
- VPN server down

## 8.6 Compliance Checklist

For MVP:
- [x] HTTPS everywhere
- [x] Password hashing (bcrypt)
- [x] JWT expiration
- [x] Input validation
- [x] SQL injection prevention
- [x] XSS prevention (React handles this)
- [x] CSRF tokens (for web portal)
- [x] Rate limiting
- [x] Security headers
- [x] Error messages don't leak info
- [x] Logs don't contain secrets

Future (when scaling):
- [ ] Penetration testing
- [ ] Security audit
- [ ] Bug bounty program
- [ ] SOC 2 compliance
- [ ] GDPR compliance
- [ ] Regular dependency updates

Outcome:
Hardened infrastructure resilient to common attacks.

---

# PHASE 9 — MONITORING & OBSERVABILITY

Essential for operating a VPN platform. You must know when things break.

## 9.1 Uptime Monitoring

**Use External Service:**

Options:
- **UptimeRobot** (free tier available)
- **Pingdom**
- **BetterUptime**

Monitor:
- `https://api.cvault.io/health` (every 5 min)
- `https://portal.cvault.io` (every 5 min)
- WireGuard server (ping check every 5 min)

Alert via:
- Email
- SMS (for critical)
- Slack webhook

## 9.2 Application Performance Monitoring (APM)

**Recommended: Prometheus + Grafana (free, self-hosted)**

**Install Prometheus:**
```bash
# On EC2 or separate monitoring server
docker run -d \
  -p 9090:9090 \
  -v /path/to/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

**prometheus.yml:**
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'cvault-backend'
    static_configs:
      - targets: ['backend:3000']
  
  - job_name: 'wireguard-server'
    static_configs:
      - targets: ['vpn-server:9586']
```

**Install Grafana:**
```bash
docker run -d \
  -p 3001:3000 \
  grafana/grafana
```

**Backend Metrics Endpoint:**
```typescript
// backend/src/routes/metrics.ts
import client from 'prom-client';

const register = new client.Registry();
client.collectDefaultMetrics({ register });

// Custom metrics
const apiRequestCounter = new client.Counter({
  name: 'api_requests_total',
  help: 'Total API requests',
  labelNames: ['method', 'route', 'status'],
});

const activeConnectionsGauge = new client.Gauge({
  name: 'vpn_active_connections',
  help: 'Number of active VPN connections',
});

register.registerMetric(apiRequestCounter);
register.registerMetric(activeConnectionsGauge);

app.get('/metrics', async (req, reply) => {
  reply.type('text/plain');
  return register.metrics();
});
```

## 9.3 Server Metrics (WireGuard VPS)

**Install Node Exporter:**
```bash
wget https://github.com/prometheus/node_exporter/releases/download/v*/node_exporter-*.tar.gz
tar xvfz node_exporter-*.tar.gz
cd node_exporter-*
./node_exporter &
```

**WireGuard Metrics:**

Install WireGuard exporter:
```bash
wget https://github.com/MindFlavor/prometheus_wireguard_exporter/releases/download/...
./prometheus_wireguard_exporter
```

Metrics exposed:
- Number of peers
- Bytes sent/received per peer
- Last handshake time

## 9.4 Dashboards

**Grafana Dashboard Panels:**

**Backend Dashboard:**
- API request rate (requests/sec)
- Error rate (%)
- Response time (p50, p95, p99)
- Active connections
- Database connection pool
- Memory usage
- CPU usage

**VPN Dashboard:**
- Active VPN connections
- Total bandwidth (GB/day)
- Bandwidth per server
- Connection success rate
- Average connection duration
- Geographic distribution

**Business Dashboard:**
- Active tenants
- Users per tenant
- API calls per tenant
- Top bandwidth consumers

## 9.5 Alerting Rules

**Critical Alerts** (immediate action):
- API down (> 1 min)
- VPN server down
- Database unreachable
- CPU > 90% for > 5 min
- Disk > 90%

**Warning Alerts** (investigate soon):
- Error rate > 5%
- Response time > 1s (p95)
- Memory > 80%
- Failed login rate spike

**Send alerts via:**
```yaml
# alertmanager.yml
route:
  receiver: 'email'
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h

receivers:
  - name: 'email'
    email_configs:
      - to: 'alerts@cvault.io'
        from: 'alertmanager@cvault.io'
```

## 9.6 Log Aggregation

**Simple Option (MVP):**
Use CloudWatch Logs (AWS native)

**Advanced Option:**
ELK Stack (Elasticsearch, Logstash, Kibana)

**Send Logs:**
```typescript
// Use pino-cloudwatch transport
import pino from 'pino';
import { createWriteStream } from 'pino-cloudwatch';

const stream = createWriteStream({
  logGroupName: '/cvault/backend',
  logStreamName: 'production',
});

const logger = pino(stream);
```

**Search Logs:**
```bash
# CloudWatch Logs Insights query
fields @timestamp, @message, userId, action
| filter action = "login"
| stats count() by userId
| sort count desc
```

## 9.7 Usage Analytics

Track for business insights:
- Daily active tenants
- New signups per week
- Churn rate
- Average bandwidth per tenant
- Most popular server regions
- SDK version distribution

Store in database or analytics tool (Mixpanel, Amplitude).

Outcome:
Full visibility into system health and ability to respond to issues before users notice.

---

# PHASE 10 — TESTING & VALIDATION

Comprehensive testing before launch.

## 10.1 Unit Testing

**Backend Tests:**

Framework: Jest or Vitest

```typescript
// tests/services/auth.test.ts
import { describe, it, expect } from 'vitest';
import { AuthService } from '../src/services/auth.service';

describe('AuthService', () => {
  it('should hash password correctly', async () => {
    const hashed = await AuthService.hashPassword('password123');
    expect(hashed).not.toBe('password123');
    expect(await AuthService.verifyPassword('password123', hashed)).toBe(true);
  });

  it('should reject weak passwords', async () => {
    await expect(
      AuthService.register('user@test.com', '123')
    ).rejects.toThrow('Password too short');
  });
});
```

**Run tests:**
```bash
npm test
npm run test:coverage  # Aim for >80% coverage
```

## 10.2 Integration Testing

**API Tests:**

Framework: Supertest

```typescript
// tests/api/auth.test.ts
import request from 'supertest';
import { app } from '../src/app';

describe('POST /auth/register', () => {
  it('should register new user', async () => {
    const res = await request(app)
      .post('/api/v1/auth/register')
      .set('X-API-Key', 'test_tenant_key')
      .send({
        email: 'newuser@test.com',
        password: 'SecurePass123!'
      });
    
    expect(res.status).toBe(201);
    expect(res.body).toHaveProperty('access_token');
  });

  it('should reject duplicate email', async () => {
    // Register once
    await request(app)
      .post('/api/v1/auth/register')
      .set('X-API-Key', 'test_tenant_key')
      .send({ email: 'test@test.com', password: 'pass' });
    
    // Try again
    const res = await request(app)
      .post('/api/v1/auth/register')
      .set('X-API-Key', 'test_tenant_key')
      .send({ email: 'test@test.com', password: 'pass' });
    
    expect(res.status).toBe(409);
  });
});
```

## 10.3 End-to-End Testing

**Full Flow Test:**

1. **Tenant Setup**
   - Create tenant in database (or via signup API)
   - Get API key and secret

2. **User Registration**
   ```bash
   curl -X POST https://api.cvault.io/api/v1/auth/register \
     -H "X-API-Key: tenant_abc123" \
     -H "X-API-Secret: secret_xyz" \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"TestPass123!"}'
   ```
   - Verify: User created in database
   - Verify: JWT returned

3. **User Login**
   ```bash
   curl -X POST https://api.cvault.io/api/v1/auth/login \
     -H "X-API-Key: tenant_abc123" \
     -H "X-API-Secret: secret_xyz" \
     -d '{"email":"test@example.com","password":"TestPass123!"}'
   ```
   - Verify: JWT returned

4. **Device Registration**
   ```bash
   curl -X POST https://api.cvault.io/api/v1/devices \
     -H "X-API-Key: tenant_abc123" \
     -H "Authorization: Bearer <jwt>" \
     -d '{"device_name":"Test Device"}'
   ```
   - Verify: Device created in database
   - Verify: WireGuard keypair generated
   - Verify: IP allocated from pool
   - Verify: Config returned

5. **VPN Connection**
   - Save config to file
   - Connect using WireGuard CLI:
     ```bash
     wg-quick up /tmp/test-config.conf
     ```
   - Verify: Tunnel established (check `wg show`)
   - Verify: IP changed (check `curl ifconfig.me`)
   - Verify: Internet works (browse websites)

6. **Connection Tracking**
   ```bash
   curl https://api.cvault.io/api/v1/vpn/status \
     -H "Authorization: Bearer <jwt>"
   ```
   - Verify: Session recorded in database
   - Verify: Status shows "connected"

7. **Disconnect**
   ```bash
   wg-quick down /tmp/test-config.conf
   ```
   - Verify: Tunnel closed
   - Verify: Session updated in database

8. **Cleanup**
   - Delete device
   - Verify: IP released back to pool
   - Verify: Peer removed from WireGuard server

## 10.4 Load Testing

**Tools:** k6 or Artillery

Test scenarios:
- 100 concurrent connections
- 1000 API requests/second
- Sustained bandwidth test (stream data through VPN)

```javascript
// load-test.js (k6)
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 100,  // 100 virtual users
  duration: '5m',
};

export default function() {
  const res = http.post('https://api.cvault.io/api/v1/auth/login', {
    email: 'test@example.com',
    password: 'pass',
  }, {
    headers: { 'X-API-Key': 'test_key' },
  });
  
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

Run:
```bash
k6 run load-test.js
```

## 10.5 Security Testing

**Manual Checks:**
- [ ] SQL injection attempts (various payloads)
- [ ] XSS attempts in user inputs
- [ ] CSRF protection on state-changing requests
- [ ] API rate limit enforcement
- [ ] JWT expiration and refresh
- [ ] Wrong API key rejection
- [ ] Password strength enforcement

**Automated Tools:**
```bash
# OWASP ZAP
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t https://api.cvault.io

# npm audit
npm audit
npm audit fix
```

## 10.6 Platform-Specific Testing

**Desktop App:**
- Test on macOS (your primary platform)
- Test on Windows VM
- Test WireGuard CLI integration
- Test auto-reconnect
- Test network changes (WiFi -> Ethernet)

**Mobile App:**
- Test on iPhone (TestFlight)
- Test on Android (APK)
- Test NetworkExtension/VpnService integration
- Test background operation
- Test kill switch

## 10.7 Acceptance Criteria

Before calling it done:
- [x] User can register account
- [x] User can login
- [x] User can register device
- [x] User receives valid WireGuard config
- [x] User can connect to VPN
- [x] IP changes after connection
- [x] Internet works through VPN
- [x] DNS works correctly
- [x] User can disconnect
- [x] Multiple users can connect simultaneously (test with 10+ users)
- [x] Multiple tenants are isolated (user A can't see user B's devices)
- [x] Usage is tracked per tenant
- [x] API keys work correctly
- [x] Rate limiting works
- [x] Developer portal displays correct stats
- [x] All tests pass
- [x] No errors in logs during normal operation
- [x] Monitoring alerts work

Outcome:
Validated, production-ready VPN platform.

---

# PHASE 11 — DEPLOYMENT & CI/CD

Automate deployments for faster iterations.

## 11.1 Git Repository Structure

```
cvault/
├── backend/             # Control plane API
├── developer-portal/    # Next.js tenant dashboard
├── demo-desktop/        # Flutter desktop app
├── demo-mobile/         # Flutter mobile app
├── demo-web/            # React web demo
├── sdk-js/              # JavaScript SDK
├── sdk-flutter/         # Flutter SDK
├── docs/                # Documentation
└── infrastructure/      # Terraform/CloudFormation
```

## 11.2 GitHub Actions CI/CD

**Backend CI/CD** (`.github/workflows/backend.yml`):
```yaml
name: Backend CI/CD

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
  pull_request:
    paths:
      - 'backend/**'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
      - run: cd backend && npm ci
      - run: cd backend && npm test
      - run: cd backend && npm run lint

  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to EC2
        env:
          SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          echo "$SSH_KEY" > key.pem
          chmod 600 key.pem
          ssh -i key.pem -o StrictHostKeyChecking=no ubuntu@$HOST << 'EOF'
            cd /var/www/cvault-backend
            git pull origin main
            npm ci
            npm run build
            pm2 restart cvault-backend
          EOF
```

**SDK Publishing** (`.github/workflows/sdk-js.yml`):
```yaml
name: Publish JS SDK

on:
  push:
    tags:
      - 'sdk-js-v*'

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
      - run: cd sdk-js && npm ci
      - run: cd sdk-js && npm test
      - run: cd sdk-js && npm run build
      - run: cd sdk-js && npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

## 11.3 Docker Configuration

**backend/Dockerfile:**
```dockerfile
FROM node:20-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy source
COPY . .

# Build
RUN npm run build

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    restart: unless-stopped

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    volumes:
      - grafana_data:/var/lib/grafana
    restart: unless-stopped

volumes:
  redis_data:
  prometheus_data:
  grafana_data:
```

## 11.4 Environment Management

**Development (.env.development):**
```
API_URL=http://localhost:3000
DATABASE_URL=postgresql://localhost:5432/cvault_dev
LOG_LEVEL=debug
```

**Production (.env.production):**
```
API_URL=https://api.cvault.io
DATABASE_URL=postgresql://rds-endpoint/cvault
LOG_LEVEL=info
```

Never commit `.env` files - use `.env.example` as template.

## 11.5 Database Migrations

Use Prisma migrations:

```bash
# Create migration
npx prisma migrate dev --name add_usage_metrics

# Apply to production
npx prisma migrate deploy
```

**Automated in CI/CD:**
```yaml
- name: Run migrations
  run: cd backend && npx prisma migrate deploy
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

## 11.6 Rollback Strategy

**If deployment fails:**

1. **Backend:** Revert to previous PM2 version
   ```bash
   pm2 list
   pm2 restart cvault-backend@previous
   ```

2. **Database:** Roll back migration
   ```bash
   npx prisma migrate reset  # Development only!
   # Production: Manually write down migration
   ```

3. **Frontend:** CloudFront invalidation to previous version

## 11.7 Health Checks

**Backend health endpoint:**
```typescript
// /health
app.get('/health', async (req, reply) => {
  // Check database
  const dbOk = await prisma.$queryRaw`SELECT 1`;
  
  // Check Redis
  const redisOk = await redis.ping() === 'PONG';
  
  // Check WireGuard server
  const wgOk = await checkWireGuardServer();
  
  if (dbOk && redisOk && wgOk) {
    return { status: 'healthy', timestamp: new Date() };
  } else {
    reply.status(503);
    return { status: 'unhealthy', db: dbOk, redis: redisOk, wg: wgOk };
  }
});
```

**Monitor this endpoint** with UptimeRobot or similar.

Outcome:
Streamlined deployment process with automated testing and rollback capability.

---

# DEVELOPMENT WORKFLOW

## What You Build in VS Code

Your development work focuses on:

### Backend Development
* API endpoints (Fastify routes)
* Business logic (services)
* Database models (Prisma schema)
* Authentication middleware
* WireGuard integration service
* Usage tracking workers
* Unit tests
* Integration tests

### SDK Development
* JavaScript SDK (npm package)
* Flutter SDK (pub package)
* API client libraries
* Error handling
* Test suites
* Documentation

### Developer Portal
* Next.js pages and components
* Dashboard UI
* API key management
* Usage analytics displays
* Authentication pages
* Settings pages

### Demo Applications
* Flutter desktop app (Mac, Windows, Linux)
* Flutter mobile app (iOS, Android)
* React web demo
* WireGuard integration code
* UI/UX implementation

### Infrastructure as Code
* Docker configurations
* Docker Compose files
* GitHub Actions workflows
* Deployment scripts
* Terraform/CloudFormation (optional)

### Documentation
* API documentation (OpenAPI/Swagger)
* SDK integration guides
* Code examples
* Architecture diagrams

## What You Do Outside VS Code

Manual infrastructure setup:

### VPS/Cloud Configuration
* Purchase VPS for WireGuard
* Set up AWS account
* Create EC2 instances
* Configure RDS PostgreSQL
* Set up ElastiCache Redis (optional)
* Configure security groups
* Assign Elastic IPs

### Server Administration
* SSH into servers
* Install WireGuard on VPS
* Configure UFW firewall
* Set up Fail2ban
* Enable IP forwarding
* Configure iptables rules
* Install Nginx
* Set up SSL certificates (Certbot)

### Domain Management
* Purchase domain name
* Configure DNS records (Route 53)
* Point domains to servers
* Set up CloudFront distributions

### Monitoring Setup
* Configure CloudWatch alarms
* Set up uptime monitoring
* Configure alert notifications
* Install Prometheus/Grafana

### Testing & Validation
* Manual VPN connection tests
* Test from different devices
* Verify IP changes
* Check internet routing
* Validate multi-tenant isolation

---

# AWS SETUP CHECKLIST

Here's what you need to do in AWS Console:

## EC2 (Backend API Server)
1. Launch EC2 instance (t3.small Ubuntu 22.04)
2. Create/assign Elastic IP
3. Create security group:
   - Allow 22 (SSH) from your IP
   - Allow 80 (HTTP) from 0.0.0.0/0
   - Allow 443 (HTTPS) from 0.0.0.0/0
4. Create SSH key pair and download
5. SSH into instance and install Docker, Docker Compose, Nginx
6. Clone your backend repository
7. Set up environment variables
8. Start backend with Docker Compose

## RDS (PostgreSQL Database)
1. Create PostgreSQL instance (db.t3.micro for MVP)
2. Choose version 15+
3. Set master password
4. Create security group:
   - Allow 5432 from backend EC2 security group only
5. Enable automated backups (7 days retention)
6. Enable encryption at rest
7. Note down endpoint URL
8. Create database: `cvault`
9. Run Prisma migrations from your backend

## ElastiCache (Redis - Optional for MVP)
1. Create Redis cluster (cache.t3.micro)
2. Create security group:
   - Allow 6379 from backend EC2 security group only
3. Note down endpoint URL
4. Update backend environment variables

## Route 53 (DNS)
1. Create hosted zone for your domain
2. Create A records:
   - `api.cvault.io` → EC2 Elastic IP
3. Create CNAME records:
   - `portal.cvault.io` → CloudFront distribution
   - `demo.cvault.io` → CloudFront distribution
4. Update nameservers at domain registrar

## CloudFront (Frontend CDN)
1. Create distribution for developer portal
   - Origin: S3 bucket with Next.js build
   - Enable HTTPS
   - Create/attach ACM certificate
2. Create distribution for demo web app
3. Set up custom domain names

## S3 (Static Hosting & Backups)
1. Create bucket for developer portal build
2. Create bucket for demo web app
3. Create bucket for database backups
4. Enable versioning on backup bucket
5. Set up lifecycle rules (delete after 30 days)

## ACM (SSL Certificates)
1. Request certificate for `*.cvault.io`
2. Validate via DNS (creates records in Route 53)
3. Attach to CloudFront distributions

## Secrets Manager (Production Secrets)
1. Create secret: `cvault/jwt-secret`
2. Create secret: `cvault/api-encryption-key`
3. Create secret: `cvault/database-url`
4. Update backend code to fetch secrets

## CloudWatch (Logs & Alarms)
1. Create log group: `/cvault/backend`
2. Create alarms:
   - High CPU (> 80%)
   - High disk usage (> 85%)
   - API errors (> 5% of requests)
3. Set up SNS topic for alerts
4. Add your email to SNS subscriptions

## Cost Estimate (Monthly - MVP)

| Service | Configuration | Cost |
|---------|--------------|------|
| EC2 (backend) | t3.small | ~$15 |
| RDS (PostgreSQL) | db.t3.micro | ~$15 |
| ElastiCache (Redis) | cache.t3.micro | ~$13 |
| WireGuard VPS | 2GB RAM (DigitalOcean) | $12 |
| Route 53 | Hosted zone + queries | ~$1 |
| CloudFront | Low traffic | ~$1 |
| S3 | Static hosting | ~$1 |
| Data Transfer | 100 GB | ~$9 |
| **Total** | | **~$67/month** |

*Note: Bandwidth costs will increase with VPN usage.*

---

# FINAL ARCHITECTURE OVERVIEW

```
┌─────────────────────────────────────────────────────────────┐
│                    Business Customers                        │
│  (Sign up → Get API keys → Integrate → Deploy)             │
└───────────────────────┬─────────────────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
   ┌────▼─────┐                  ┌──────▼───────┐
   │Developer │                  │   Their      │
   │ Portal   │                  │   Apps       │
   │(Next.js) │                  │(Using SDKs)  │
   └────┬─────┘                  └──────┬───────┘
        │                               │
        └───────────────┬───────────────┘
                        │
                ┌───────▼────────┐
                │   API Backend │
                │  (Fastify +   │
                │  PostgreSQL)  │
                │   [AWS EC2]   │
                └───────┬────────┘
                        │
                        │ SSH/API
                        │
                ┌───────▼────────┐
                │  WireGuard     │
                │  Server Pool   │
                │  (Shared)      │
                │   [VPS]        │
                └────────────────┘
                        │
                        │ VPN Tunnel
                        │
                ┌───────▼────────┐
                │   End Users    │
                │  (Customers'   │
                │   customers)   │
                └────────────────┘

Monitoring Layer:
  - Prometheus + Grafana (metrics)
  - CloudWatch (logs & alarms)
  - UptimeRobot (uptime)
```

## Data Flow Example

1. **Business customer** signs up on Developer Portal
2. Portal creates **Tenant** record, generates API key
3. Business customer integrates **SDK** into their app
4. SDK configured with their API key
5. **End user** opens their app, clicks "Connect VPN"
6. SDK calls **Backend API** (with tenant API key + user JWT)
7. Backend:
   - Validates tenant API key
   - Authenticates user
   - Generates WireGuard keypair
   - Allocates IP from pool
   - SSHs to WireGuard server to add peer
   - Returns config to SDK
8. SDK passes config to **WireGuard client** (OS-level)
9. **VPN tunnel** established
10. Backend records session, tracks bandwidth
11. Business customer sees **usage stats** in their dashboard

---

# SUCCESS CRITERIA

You've successfully built CVault when:

## Technical Milestones
- [x] Backend API handles multi-tenant requests correctly
- [x] WireGuard server provisions peers dynamically
- [x] SDKs successfully integrate into test apps
- [x] Demo apps connect to VPN on all platforms
- [x] Developer portal displays real-time usage
- [x] Monitoring alerts trigger on failures
- [x] All security hardening completed
- [x] Tests pass with >80% coverage
- [x] Documentation is complete

## Business Milestones
- [x] First test tenant can sign up self-service
- [x] Test tenant can integrate SDK in <30 minutes
- [x] Demo apps work flawlessly for demos
- [x] Platform handles 10+ concurrent tenants
- [x] Each tenant has isolated user pools
- [x] Usage tracking accurate per tenant
- [x] API uptime >99.5%

## The Ultimate Test
Can a developer:
1. Sign up on your portal
2. Get API keys
3. Follow documentation
4. Integrate SDK into their app
5. Deploy working VPN functionality

**...all within 1 hour?**

If yes, you've built a true **platform product**.

---

# NEXT STEPS & FUTURE ENHANCEMENTS

After MVP is live and validated:

## Phase 12 — Advanced Features
- Kill switch (block internet if VPN drops)
- Split tunneling (route specific apps through VPN)
- IPv6 support
- DNS leak prevention
- Custom DNS servers
- Multi-hop connections
- Auto-reconnect logic

## Phase 13 — White-Label Tools
- Client app builder (inject branding)
- Custom domain setup automation
- SSO integration (OAuth, SAML)
- Webhook system for events
- Custom email templates

## Phase 14 — Business Features
- Team management (multiple users per tenant)
- Role-based access control
- Audit logs
- API key rotation
- Usage-based billing integration (Stripe)
- Invoice generation
- Payment webhooks

## Phase 15 — Scale & Performance
- Multiple WireGuard server pools (by region)
- Auto-scaling servers
- CDN for config delivery
- Database read replicas
- Redis cluster
- Kubernetes deployment (if massive scale)

## Phase 16 — Mobile App Polish
- App Store submission (iOS)
- Google Play submission (Android)
- In-app purchases
- Push notifications
- Widget support

## Phase 17 — Compliance & Legal
- GDPR compliance (on-demand data export/deletion)
- SOC 2 Type II certification
- Penetration testing
- Bug bounty program
- Privacy policy generator for customers
- DMCA agent registration

## Phase 18 — Go-to-Market
- Marketing website (cvault.io)
- Blog with technical content
- Case studies
- Video tutorials
- Community forum
- Partner program
- Affiliate program

---

# CONCLUSION

This document provides a complete roadmap to build CVault as a **B2B VPN infrastructure platform** from scratch.

**Key Principles:**
1. **Multi-tenant from day one** - No rebuilding later
2. **SDK-first architecture** - Easy integration is your competitive advantage
3. **Shared infrastructure** - Keep costs low while scaling
4. **Production-ready** - Build it right the first time
5. **Demo-driven** - Let businesses test before committing

**Your competitive advantages:**
- Businesses get VPN functionality **in hours, not months**
- They avoid building/maintaining VPN infrastructure
- White-label options let them brand it as their own
- Usage-based model means they only pay for what they use
- Multi-platform SDKs work out of the box

**Start building Phase 1 today.**

Each phase builds on the previous one, so follow the order. Don't skip security or monitoring - they're essential for operating a VPN platform.

**When you're ready to start coding, begin with:**
1. Set up AWS account & EC2 instance
2. Set up WireGuard VPS
3. Initialize backend repository with Fastify + Prisma
4. Implement first API endpoint (`POST /auth/register`)
5. Test with curl
6. Build from there

Good luck building CVault. 🚀

---

End of document.
